# Submarine
An opinionated program to abstract over hardware attached to a Raspberry Pi

## Overview
This is a low-level, (hopefully) highly reliable program that interfaces with hardware and exposes an HTTP interface for it.
Additionally, events that are generated by the hardware or other sources are pushed to subscribers via HTTP.

### Architecture
The high-level API is a 16-bit address space of 16-bit values.
Mapped into this address space are *virtual devices*, which each have exactly one *alias* and may be part of any number of *groups*.
Virtual devices are derived from/mapped to *hardware devices* on numerical *ports*, which start at `0` by convention.
Virtual devices also generate *events*, which are mapped the exact same way.

Hardware devices are interact with the actual hardware attached to the RPi.
Hardware devices run asynchronously to the rest of the program and independently of each other.
They use a number of different strategies to interface with the hardware, which are abstracted away.

Events can be subscribed to.

The API is exposed via HTTP.

### Configuration
See `dist/example_config.yaml`.
Submarine expects a file named `config.yaml` with the `program` block in it.
The `devices` and `virtual_devices` blocks can be split up into multiple files for easier management and then be imported in the main config file.

## Compilation
You need a working installation of Rust, see [rustup.rs](https://rustup.rs/).
We use the most recent stable version, which you should have installed by default.

This project is configure to compile for Linux on ARMv7 (32 bit) by default, no matter from where you're compiling.
First of all, add the appropriate target to your Rust installation:
```
rustup target add armv7-unknown-linux-gnueabihf 
```
Then tell cargo how to link for that target, in `~/.cargo/config`:
```
[target.armv7-unknown-linux-gnueabihf]
linker = "arm-linux-gnueabihf-gcc"
```

Now you actually need to get the linker.
On Linux you just need to get the appropriate package (Debian):
```
sudo apt install gcc-arm-linux-gnueabihf
```
On Windows you can get pre-built binaries for this from [here](https://gnutoolchains.com/raspberry/) (8.3.0 worked for me).
Additionally, before building on Windows, invoke `env.bat`, which will set `AR` to the appropriate value.

The default target is already set to Linux ARMv7 (see `.cargo/config`), so `cargo build` will produce a debug build for that target.
`cargo build --release` produces a release build.